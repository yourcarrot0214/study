# Generic

- 재사용 가능한 클래스, 함수를 만들기 위해 다양한 타입에서 사용 가능 하도록 하는 것이 제네릭(Generic) 입니다.
- 제네릭을 이용하면 모든 타입의 객체를 다루면서 **_객체 타입의 무결성을 유지_** 할 수 있습니다.
- 제네릭을 통해 클래스나 함수 내부에서 사용되는 특정 데이터의 타입을 외부에서 지정합니다.
- 제네릭이 적용된 대상(클래스, 함수, 인터페이스)은 선언 시점이 아닌 생성 시점에 사용하는 타입을 결정합니다.
- 제네릭에 사용되는 파라미터는 타입 파라미터(Type Parameter)라 하며 관용적으로 T를 사용합니다.
- 타입 파라미터는 상속을 통해 특정 타입의 하위 타입으로 제한할 수 있습니다.

```ts
class Orange {
  private name = "Orange";
  constructor(private brix: number = 0) {}
  getName(): string {
    return this.name;
  }
  getBrix(): number {
    return this.brix;
  }
}

class Apple {
  private = "Apple";
  constructor(private brix: number = 0) {}
  getName(): string {
    return this.name;
  }
  getBrix(): number {
    return this.brix;
  }
}

// Box class 생성자는 제네릭 타입을 설정하며, 파라미터로 받는 타입과 getFruit() 메서드로 반환하는 값의 타입이 동일하다.
class Box<T> {
  constructor(private fruit: T) {}
  getFruit(): T {
    return this.fruit;
  }
}

// orangeBox는 Box 클래스 인스턴스이며, 제네릭으로 Orange 클래스 타입을 갖는다.
const orangeBox: Box<Orange> = new Box(new Orange(5));
console.log(orangeBox); // {fruit: Orange { brix: 5, name: "Orange"}}
console.log(oangeBox.getFruit().getName()); // 'Orange'

// 제네릭을 지정하지 않고 생성한 stringBox는 추론을 통해 Box<String> 타입을 갖는다.
const stringBox = new Box("Carrot");
console.log(stringBox); // {fruit: 'Carrot'}
console.lo(stringBox.getFruit().getName()); // compile error
// 제네릭 타입 'Carrot'이 가지고 있지 않은 getName() 메서드를 호출하면 컴파일 에러가 발생한다.
```
