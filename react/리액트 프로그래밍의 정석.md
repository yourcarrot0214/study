> Do it! 리액트 프로그래밍 정석 3장을 공부한 내용입니다.

# 컴포넌트를 표현하는 JSX

JSX는 JavaScript XML의 줄임말로 **자바스크립트에 XML을 추가한 확장형 문법** 으로 이해하면 됩니다.
하나의 파일에 자바스크립트와 HTML을 동시에 작성할 수 있습니다.

```js
import React from "react";

function App() {
  return (
    <>
      <h1>Hello React!</h1>
      <div>React Component</div>
    </>
  );
}

export default App;
```

## JSX의 작동 원리

리액트 엔진은 JSX의 XML 구조를 분석하여 자바스크립트 함수 코드로 변환합니다.
위 예제의 `<div>React Component</div>` 부분은 아래와 같이 변환됩니다.

```js
React.createElement("div", null, "React Component");
```

리액트를 사용하면 이런 과정들을 알 필요 없이 JSX로 화면을 빠르게 구성할 수 있습니다.
개발자는 JSX만 작성하고, 리액트 엔진은 JSX를 기존 자바스크립트로 해석하는 역할만 수행합니다.
이것을 `선언형 화면(Declarative View)` 기술이라 부릅니다.

---

# 컴포넌트와 구성 요소

> 리액트로 작성된 화면은 컴포넌트만으로 구성되어 있습니다.

## 컴포넌트의 개념

기존의 웹 프레임워크는 MVC 방식으로 정보, 화면, 구동 코들르 분리하여 관리했습니다.
정보담당을 모델(Model), 화면 담당을 뷰(View), 구동 담당을 컨트롤러(Controller)라고 부르며 **코드 관리를 효율적으로 할 수 있다**는 장점이 있으나 **MVC 각 요소의 의존성이 높아** 재활용이 어렵다는 단점이 있습니다.

컴포넌트의 등장 배경은 웹 사이트의 화면이 각 요소가 비슷하고 반복적으로 사용한 경우가 많다는 데 있습니다. 컴포넌트는 MVC의 뷰를 독립적으로 구성하여 재사용할 수 있고 컴포넌트를 통해 새로운 컴포넌트를 쉽게 만들 수도 있습니다.

컴포넌트를 조합해 화면을 구성한다고 생각하시면 되겠습니다.

## 컴포넌트의 주요 구성 요소

### 프로퍼티

상위 컴포넌트에서 하위 컴포넌트로 전달되는 **읽기 전용 데이터** 입니다.

### state

컴포넌트의 상태를 저장하고 변경할 수 있는 데이터입니다.

### 컨텍스트

부모 컴포넌트에서 생성하여 모든 자식 컴포넌트에 전달하는 데이터입니다.

---

# 컴포넌트에 데이터를 전달하는 프로퍼티

> 프로퍼티는 상위 컴포넌트가 하위 컴포넌트에 값을 전달할 때 사용합니다. 이때 프로퍼티값은 수정할 수 없다는 특징이 있습니다.

## 프로퍼티 기초

다음은 부모 컴포넌트인 App 컴포넌트에서 name이라는 프로퍼티를 자식 컴포넌트인 UserName 컴포넌트에 전달한 예제 입니다.
name과 같이 속성(attribute) 형태로 전달되는 값을 프로퍼티라고 합니다.

```js
function App() {
  return (
    <>
      <UserName name='Carrot' />
    </>
  );
}
```

여기서 중요한 점 두 가지는 **프로퍼티가 상위 컴포넌트에서 하위 컴포넌트로 전달된다**는 것과 **프로퍼티는 상위에서 하위 단방향으로 흐른다** 입니다.

## 프로퍼티의 다양한 사용 방법

프로퍼티에서는 자바스크립트의 모든 자료형을 사용할 수 있습니다. 이때 프로퍼티의 자료형은 미리 선언해 주는 것이 좋습니다.
프로퍼티의 자료형을 미리 선언하면 리액트 엔진이 프로퍼티로 전달하는 값의 변화를 효율적으로 감지할 수 있고, 개발자가 실수로 지정되지 않은 자료형을 프로퍼티에 전달하려고 할 때 경고 메시지로 알려주기 때문에 버그 예방에도 좋습니다.

프로퍼티의 자료형 선언은 리액트에서 제공하는 `prop-types`를 이용하면 됩니다.

```js
import React from "react";
import PropTypes from "prop-types";

const UserName = ({ name }) => {
  return (
    <>
      <div>{name}</div>
    </>
  );
};

// 자료형 선언
UserName.propTypes = {
  name: PropTypes.string,
};

export default UserName;
```

프로퍼티의 데이터 타입에 따라 다양한 자료형 선언을 해줄 수 있습니다.
자료형 선언은 `프로퍼티명 : 프로퍼티 타입`으로 해주면 됩니다.

```js
UserName.propTypes = {
  boolValue: PropTypes.bool,
  numberValue: PropTypes.number,
  arrayBalue: PropTypes.arrayOf(PropTypes.number),
  objectValue: PropTypes.object,
  nodeValue: PropTypes.node,
  functionValue: PropTypes.func,
};
```

객체 프로퍼티에 다양한 데이터 타입의 값이 포함되어 있다면 `PropTypes.shape`을 사용하여 각각의 키값에 맞는 데이터 타입을 선언해 줄 수 있습니다.

```js
UserName.propTypes = {
  objectValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),
};
```

특정 컴포넌트에 꼭 전달되어야 하는 필수 프로퍼티가 있다면 `isRequired`를 사용하면 됩니다.

```js
UserName.propTypes = {
  objectValue: PropTypes.shape({
    name: PropTypes.string,
    age: PropTypes.number,
  }),

  defaultValue: PropTypes.string.isRequired,
};
```

프로퍼티에 기본값을 지정하려면 `defaultProps`를 이용하면 됩니다.

```js
UserName.defaultProps = {
  name: "Carrot",
};
```

---

# 컴포넌트 상태 관리하기

> 값을 변경해야 하는 데이터를 다룰 경우 state를 사용합니다.

## state로 상태 관리하기

state는 **값을 저장하거나 변경할 수 있는 객체**로 보통 버튼을 클릭하거나 값을 입력하는 등의 이벤트와 함께 사용됩니다.

```js
import React from "react";

class StateExample extends React.component {
  constructor(props) {
    super(props);

    // state 정의
    this.state = {
      loading: true,
      formData: "no data",
    };

    this.handleData = this.handleData.bind(this);

    setTimeout(this.handleData, 4000);
  }

  handleData() {
    const data = "new data";
    const { formData } = this.state;

    // state 변경
    this.setState({
      loading: false,
      formData: data + formData,
    });

    console.log(`loading값은 ${this.state.loading} 입니다.`);
  }

  render() {
    return (
      <div>
        <span>로딩중 : {String(this.state.loading)}</span>
        <span>결과 : {this.state.formData}</span>
      </div>
    );
  }
}

export default StateExample;
```

state를 사용할 때 주의할 점은 다음과 같습니다.

1. 생성자(constructor)에서 반드시 초기화 해야 합니다.
2. state값을 변경할 때는 **setState()함수**를 반드시 상용해야 합니다.
3. setState() 함수는 비동기로 처리되며, setState()코드 이후로 연결된 함수들의 실행이 완료된 시점에 화면 동기화 과정을 거칩니다.

### state값은 setState() 함수로 변경해야 합니다.

state값을 직접 변경하면 안 되는 이유는 render() 함수로 화면을 그려주는 시점은 리액트 엔진이 정하기 때문입니다. 직접 state값을 변경해도 render() 함수는 새로 호출되지 않고 setState() 함수를 호출하여 state값을 변경해야 리액트 엔진이 자동으로 render() 함수를 호출하므로 화면에 변경된 state값을 새롭게 출력할 수 있습니다.

### setState() 함수의 인자로 함수를 전달하면 이전 state값을 쉽게 읽을 수 있습니다.

```js
handleData(data) {
    this.setState((prev) => ({
        loading: false,
        formData: data + prev.formData
    }))
}
```

---

# 컴포넌트의 생명주기

> 컴포넌트의 생성부터 소멸까지의 과정을 컴포넌트의 생명주기(LifeCycle)라고 부릅니다. 컴포넌트는 생명주기마다 함수를 가지고 있는데 이 함수들을 이용하면 특정 시점에 원하는 동작을 하도록 만들 수 있습니다.

## 생명주기 함수 살펴보기

<img src="https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F999512335C49891D19D458" />

- 생명주기 함수는 render() 함수를 포함하여 총 8종의 함수가 있습니다.
- 생명주기 함수는 리액트 엔진이 자동으로 호출합니다.
- 컴포넌트가 생성될 때 4개의 생명주기 함수가 호출됩니다.
  - constructor
  - getDerivedStateFromProp
  - render
  - componentDidMount
- 컴포넌트 생성 후 갱신 완료(업데이트)까지 5개의 생명주기 함수가 호출됩니다.
  - getDerivedStateFromProp
  - shouldComponentUpdate
    - 이 함수의 반환값이 true일 경우 이후 과정이 진행되고 false일 경우 이후 과정이 모두 생략됩니다.
  - render
  - getSnapshotBeforeUpdate
  - componentDidUpdate
- 컴포넌트 갱신완료 후 소멸(제거될 때) 완료까지 1개의 생명주기 함수가 호출됩니다.
  - componentWillUnmount

### constructor(props) 함수

- 맨 처음 생성될 때 한 번만 호출되며, 상태(state, 객체 변수)를 선언할 때 사용됩니다.
- constructor() 함수를 정의할 때는 **항상 super() 함수를 가장 위에 호출해야 합니다.**
- super() 함수는 프로퍼티와 생명 주기 상태 등을 초기화하는 중요한 과정을 포함하고 있습니다.

```js
constructor(props) {
    super(props);
    // 이후 추가적인 state data 혹은 변수를 선언합니다.
}
```

### render() 함수

- 데이터가 변경되어 새 화면을 출력해야 할 때 자동으로 호출되는 함수입니다.
- render() 함수가 반환하는 JSX를 화면에 그려줍니다.

### static getDerivedStateFromProps(props, state) 함수

- 정적 함수입니다. 따라서 함수 안에서 this.props나 this.state와 같은 방법으로 접근할 수 없습니다.
- 값에 접근해야 하는 경우 반드시 인자로 전달된 props, state를 이용해야 합니다.
- 이때 props는 상위 컴포넌트에서 전달받은 프로퍼티로 state값을 연동할 때 주로 사용되며, 반환 값으로 state를 변경합니다.

### componentDiddMount() 함수

- rendder() 함수가 JSX를 화면에 출력한 이후 호출되는 함수입니다.
- 컴포넌트가 화면에 모두 출력된 이후 해야하는 작업들은 여기서 하면 됩니다.

### shouldComponentUpdate(nextProps, nextState) 함수

- 프로퍼티를 변경하거나 setState() 함수를 호출하여 state값을 변경하면 **화면을 새로 출력해야 하는지** 판단하는 함수입니다.
- 이 함수는 화면을 새로 출력할지 여부를 판단하며, 데이터 변화를 비교하는 작업을 포함하므로 리액트 성능에 영향을 많이 줍니다.
- 화면 변경을 위해 검증 작업을 해야하는 경우 이 함수를 사용하면 됩니다.
- 내장 함수인 forceUpdate() 함수를 호출하여 화면을 출력하면 이 함수는 호출되지 않습니다.

### getSnapshotBeforeUpdate(prevProps, prevState) 함수

- 컴포넌트의 변경된 내용이 가상 화면에 완성된 이후 호출되는 함수입니다.
- 이 함수는 컴포넌트가 화면에 실제로 출력되기 전에 호출되므로 화면에 출력될 엘리먼트의 크기 또는 스크롤 위치 등의 **DOM 정보에 접근할 때 사용** 됩니다.

### componentDidUpdate(prevProps, prevState, snapshot) 함수

- 컴포넌트가 실제 화면에 출력된 이후 호출되는 함수입니다.
- 이 함수는 부모 컴포넌트로부터 전달된 이전 프로퍼티(prevProps)와 이전 state값(prevState)과 함께 getSnapshotBeforeUpdate() 함수에서 반환된 값(snapshot)을 인자로 전달받습니다.
- 이 값들을 이용하여 스크롤 위치를 옮기거나 커서를 이동시키는 등의 **DOM 정보를 변경할 때 사용** 됩니다.

### componentWillUnmount() 함수

- 컴포넌트가 소멸되기 직전에 호출되는 함수입니다.
- 보통 컴포넌트에서 감시하고 있는 작업들을 해제할 때 필요한 함수입니다.
  - 예를 들어 컴포넌트에서 setInterval() 함수가 사용되었다면, 이 함수에서 clearInterval() 함수로 해제해 주어야 합니다.
  - 이러한 해제 작업이 생략되면 메모리 누수 현상이 발생하여 웹 브라우저의 작동이 멈추기도 합니다.

---

## 생명주기 함수의 실행 과정 살펴보기

### 생성 과정의 생명주기 함수들 실행

```js
// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root));
```

- index.js 파일의 ReactDOM.render() 함수가 실행되면 App 컴포넌트의 최초 생명주기 함수인 constructor()가 실행됩니다.
- App 컴포넌트가 포함한 자식 컴포넌트 역시 독립적인 생명주기를 가집니다.

```js
// App 컴포넌트의 자식 컴포넌트 LifecycleExample
import React from "react";

class LifecycleExample extends React.component {
  static getDerivedStateFromProps() {
    console.log("getDerivedStateFromProps() 호출");
    return {};
  }

  constructor(props) {
    super(props);
    // getDerivedStateFromProps() 함수를 사용하므로
    // 경고 메시지를 건너 뛰기 위해 state 초기값을 설정합니다.
    this.state = {};
    console.log("constructor() 호출");
  }

  componentDidMount() {
    console.log("componentDidMount() 호출");
  }

  componentDidUpdate() {
    console.log("componentDidUpdate() 호출");
  }

  componentWillUnmount() {
    console.log("componentWillUnmount() 호출");
  }

  getSnapshotBeforeUpdate() {
    console.log("getSnapshotBeforeUpdate() 호출");
    return {};
  }

  shouldComponentUpdate() {
    console.log("shouldComponentUpdate() 호출");
    return true;
  }

  render() {
    console.log("render() 호출");
    return null;
  }
}

export default LifecycleExample;
```

App 컴포넌트에서 `<LifecycleExample />`를 포함시켜 리액트 서버를 구동해 보면 생명주기 함수에 있는 console.log 메시지를 확인할 수 있습니다.

```js
// console
"constructor() 호출";
"getDerivedStateFromProp() 호출";
"render() 호출";
"componentDidMount() 호출";

```

컴포넌트 생명주기의 실행 과정은 다음과 같습니다.
|컴포넌트 생성|
|--|
|1. constructor|
|2. getDerivedStateFromProps|
|3. render|
|4. componentDidMount|
|컴포넌트 생성 완료|

### 변경 과정의 생명주기 함수들 실행

변경 과정의 생명주기 함수들은 **상위 컴포넌트의 프로퍼티나 state의 변화가 생기면 실행** 됩니다. <br>
`<LifecycleExample />` 컴포넌트의 componentDidMount() 함수에 setState() 함수를 사용하여 state값을 변경해 봅시다.

```js
// LifecycleExample.jsx
componentDidMount() {
    console.log('componentDidMount() 호출');
    this.setState({updated: true});
}
```

```
// console
constructor() 호출
getDerivedStateFromProps() 호출
render() 호출
componentDidMount() 호출
getDerivedStateFromProps() 호출
shouldComponentUpdate() 호출
render() 호출
getSnapshotBeforeUpdate() 호출
componentDidUpdate() 호출
```

- 생성 과정의 마지막 단계인 componentDidMount() 함수에 setState() 함수를 호출하여 state를 변경했습니다.
- 변경 과정은 shouldComponentUpdate() 함수의 반환값이 true인 경우 진행되므로 변경 과정의 모든 생명주기 함수들의 호출 과정을 확인할 수 있습니다.
- componentDidMount() 호출 메시지 이후 내용들이 setState() 함수 호출 이후에 실행되는 생명주기 함수가 출력하는 내용입니다.

이번에는 shouldComponentUpdate() 함수의 반환값이 false 일때의 과정을 살펴봅시다.

```js
// LifecycleExample.jsx
shouldComponentUpdate() {
    console.log('shouldComponentUpdate() 호출');
    return false;
}
```

```
// console
constructor() 호출
getDerivedStateFromProps() 호출
render() 호출
componentDidMount() 호출
getDerivedStateFromProps() 호출
shouldComponentUpdate() 호출
```

shouldComponentUpdate() 함수의 반환값이 false 이므로 **리액트 엔진은 데이터 비교 후 변경 사항이 없다**고 판단하여 이후 변경 과정의 생명주기 함수가 실행되지 않습니다.<br>
만약 shouldComponentUpdate() 함수의 결과값과 상관없이 화면 동기화 과정을 진행하고 싶다면 componentDidMount() 함수에 `this.forceUpdate()` 함수를 호출하면 됩니다.

| 변경 생명주기 실행 과정  | 비고                               |
| ------------------------ | ---------------------------------- |
| 생성완료                 | forceUpdate() 실행시 render로 이동 |
| getDerivedStateFromProps |
| shouldComponentUpdate    | 반환값이 false이면 갱신 완료       |
| render                   |
| getSnapshotBeforeUpdate  |
| componentDidUpdate       |
| 갱신완료                 |

---

### 소멸 과정의 생명주기 함수들 실행

소멸 과정은 컴포넌트가 화면에서 생략되면 시작됩니다.<br>
소멸 과정의 생명주기 함수를 실행해 보기 위해 App 컴포넌트를 다음과 같이 변경하겠습니다.

```js
// App.jsx
import React from 'react';
import LifecycleExample from './LifecycleExample.jsx';

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            hasDestroyed : false
        }
    }

    componentDidMount() {
        this.setState({hasDestroyed: true};)
    }

    render() {
        return (
            <>
                {this.state.hasDestroyed ? null : <LifecycleExample />}
            </>
        )
    }
}

exrpot default App;
```

```
// console
constructor() 호출
getDerivedStateFromProps() 호출
render() 호출
componentDidMount() 호출
componentWillUnmount() 호출
```

- componentDidMount() 호출 뒤 setState() 함수로 state값을 변경하여 LifecycleExample 컴포넌트가 출력되지 않도록 코드를 작성하였습니다.
- 이후 콘솔창에서와 같이 곧바로 componentWillUnmount() 함수가 호출되었음을 확인할 수 있습니다.

| 소멸 생성주기 실행 과정 |
| ----------------------- |
| 생성&갱신 완료          |
| componentWililUnmount   |
| 소멸 완료               |
